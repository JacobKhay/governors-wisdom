<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Wisdom and Governors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="analysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="analysis_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="analysis_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="analysis_files/libs/quarto-html/popper.min.js"></script>
<script src="analysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="analysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="analysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="analysis_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="analysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="analysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="analysis_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wisdom and Governors</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="background-information" class="level2">
<h2 class="anchored" data-anchor-id="background-information">Background Information</h2>
<p>This dataset is drawn from an attempt to estimate the causal effect of winning an election on the subsequent lifespan of political candidates. The study includes data from candidates who participated in competitive elections, with the treatment defined as winning versus losing a narrowly decided race. By focusing on close contests, the analysis aims to approximate random assignment, helping to address confounding variables that might otherwise bias estimates. The dataset records each candidate’s age at election, party affiliation, gender, vote margin, and eventual age at death, allowing for regression-based modeling of the relationship between electoral outcomes and longevity.</p>
<p>Commentary: http://www.stat.columbia.edu/~gelman/research/published/causal_paths_3.pdf Response: https://erikgahner.dk/2020/a-response-to-andrew-gelman/</p>
<section id="scenarios" class="level3">
<h3 class="anchored" data-anchor-id="scenarios">Scenarios</h3>
<ol type="1">
<li>Imagine you work for a life insurer, and want to forecast how long a newly elected Senator might live based on their age, party, and other variables.</li>
</ol>
<p>Predictive Model. Units:</p>
<ol start="2" type="1">
<li>Imagine you are a researcher. You want to know if winning candidates live longer.</li>
</ol>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>For this assignment, we will use the <code>governors</code> dataset, which contains information on U.S. gubernatorial candidates and their election outcomes. This dataset comes from published research and is available in the <code>primer.data</code> package.</p>
<ul>
<li>Explore the data. What is the outcome variable? How is it distributed? Outcome variable: lived_after</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 9 × 7
  term             estimate std.error statistic   p.value conf.low conf.high
  &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
1 (Intercept)        56.9      2.57     22.1    7.61e-102  51.8       61.9  
2 statusIncumbent     5.31     0.676     7.86   5.18e- 15   3.99       6.64 
3 election_age       -0.686    0.0166  -41.3    3.64e-305  -0.719     -0.654
4 partyRepublican     1.55     0.403     3.84   1.25e-  4   0.758      2.34 
5 partyThird party   -4.92     1.58     -3.12   1.84e-  3  -8.02      -1.82 
6 sexMale             0.217    2.37      0.0915 9.27e-  1  -4.43       4.87 
7 regionNortheast    -0.148    0.523    -0.283  7.77e-  1  -1.17       0.878
8 regionSouth         1.02     0.544     1.88   6.05e-  2  -0.0451     2.09 
9 regionWest          1.39     0.596     2.33   1.97e-  2   0.222      2.56 </code></pre>
</div>
</div>
</section>
<section id="preceptor-table" class="level3">
<h3 class="anchored" data-anchor-id="preceptor-table">Preceptor Table</h3>
<p>What sorts of questions are we trying to answer?</p>
<p>Given a candidate’s age at election, party affiliation, sex, and region, how many years do we expect them to live after the election?</p>
<p>In order to build the Preceptor Table, we need to know: Is the model causal or predictive? What are units? What are the outcomes? What are the covariates? What are the treatments? Describe the mathematical Structure of the model.</p>
<p>Predictive — the goal is to forecast post-election lifespan using candidate attributes. Each row represents one gubernatorial candidate in a U.S. state election. The outcome is lived_after, the number of years the candidate lived after their election. Covariates include election_age, party, sex, region, year, status, and win_margin. There is no treatment, since the focus is on prediction, not causal inference. The model uses a linear regression structure to estimate post-election lifespan as a function of these covariates, enabling forecasts for future candidates based on their characteristics.</p>
<p><span class="math display">\[
\widehat{\text{lived\_after}} = 56.9 + 5.31 \cdot \text{Incumbent} - 0.686 \cdot \text{ElectionAge} + 1.55 \cdot \text{Republican} - 4.92 \cdot \text{ThirdParty} + 0.217 \cdot \text{Male} - 0.148 \cdot \text{Northeast} + 1.02 \cdot \text{South} + 1.39 \cdot \text{West}
\]</span></p>
</section>
<section id="population-table" class="level3">
<h3 class="anchored" data-anchor-id="population-table">Population Table</h3>
<p>Describe the Population Table in your own words—what does each row represent in this context? Then, for each of the four key assumptions (validity, stability, representativeness, and unconfoundedness), provide both a definition in your own words and one specific counter-example for each assumption.</p>
<p>Each row in the Population Table represents a single gubernatorial candidate who ran in a U.S. state election between 1789 and 2020. For each candidate, the dataset records demographic information (e.g., age at election, sex, party, region), election details (e.g., status, vote margin), and post-election lifespan (lived_after).</p>
<p>Validity: Definition: The data accurately reflects the real-world outcome and predictors. Variables are correctly measured and coded.</p>
<p>Counter-example: If the status variable misclassifies some losing candidates as winners (due to bad records or typos), any estimates involving status will be invalid.</p>
<p>Stability: Definition: The relationship between predictors and outcomes would remain the same if the model were applied at a different time or place.</p>
<p>Counter-example: If medical technology drastically improved in recent decades, candidates elected in the 2000s might live longer after elections than those in the 1800s — even if they share the same characteristics — violating stability.</p>
<p>Representativeness Definition: The sample of candidates in the dataset is similar to the broader group we care about (e.g., future candidates, all political leaders, or all older adults).</p>
<p>Counter-example: If the dataset only includes candidates from highly contested races or southern states, it might not represent the broader population of governors or politicians.</p>
<p>Unconfoundedness: Definition: All variables that affect both the treatment (winning) and the outcome (lifespan) are observed and included in the model.</p>
<p>Counter-example: If healthier candidates are more likely to win and live longer — but health is not measured in the data — then the estimated effect of winning will be biased due to confounding.</p>
</section>
<section id="modeling" class="level3">
<h3 class="anchored" data-anchor-id="modeling">Modeling</h3>
<p>The outcome variable in this study is <code>death_age</code>, which is the age each political candidate died. What kind of regression model should you use to predict or explain death_age? Explain your choice based on what kind of variable <code>death_age</code> is?</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Parameter           | Coefficient |   SE |         95% CI | t(3568) |      p
----------------------------------------------------------------------------
(Intercept)         |       56.86 | 2.57 | [51.83, 61.90] |   22.14 | &lt; .001
status [Incumbent]  |        5.31 | 0.68 | [ 3.99,  6.64] |    7.86 | &lt; .001
election age        |        0.31 | 0.02 | [ 0.28,  0.35] |   18.88 | &lt; .001
party [Republican]  |        1.55 | 0.40 | [ 0.76,  2.34] |    3.84 | &lt; .001
party [Third party] |       -4.92 | 1.58 | [-8.02, -1.82] |   -3.12 | 0.002 
sex [Male]          |        0.22 | 2.37 | [-4.43,  4.87] |    0.09 | 0.927 
region [Northeast]  |       -0.15 | 0.52 | [-1.17,  0.88] |   -0.28 | 0.777 
region [South]      |        1.02 | 0.54 | [-0.05,  2.09] |    1.88 | 0.061 
region [West]       |        1.39 | 0.60 | [ 0.22,  2.56] |    2.33 | 0.020 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># Indices of model performance

AIC       |      AICc |       BIC |    R2 | R2 (adj.) |   RMSE |  Sigma
-----------------------------------------------------------------------
27809.773 | 27809.834 | 27871.595 | 0.117 |     0.115 | 11.770 | 11.785</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 4
  death_age .fitted .lower .upper
      &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
1      54.6    74.0   50.9   97.2
2      59.3    71.0   47.9   94.1
3      59.3    71.6   48.5   94.8
4      66.1    74.0   50.9   97.1
5      66.1    74.6   51.5   97.7
6      54.1    71.8   48.6   94.9</code></pre>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>